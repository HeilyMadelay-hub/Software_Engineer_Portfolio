1️⃣ Principio de inversión de dependencias (DIP)

El DIP dice:

“Las clases de alto nivel no deben depender de clases de bajo nivel; ambas deben depender de abstracciones (interfaces o clases abstractas).”

En palabras más simples:

Alto nivel: CameraHub (orquesta la interacción, no sabe de algoritmos)

Bajo nivel: GestureDetectorService (implementa la lógica de detección)

Abstracción: IGestureDetectorService

Esto permite que CameraHub use cualquier implementación que cumpla el contrato, sin acoplarse a detalles concretos.

2️⃣ ¿Siempre inyectas interfaces?

En la mayoría de casos sí, especialmente en servicios complejos, testables o cambiables:

private readonly IGestureDetectorService _gestureDetectorService;


Cuando no es necesario:

Servicios muy simples, pequeños y estables.

Clases internas que nunca cambiarán ni se mockearán.

Proyectos muy pequeños donde el overhead de abstraer no aporta.

3️⃣ Beneficios de inyectar interfaces

Flexibilidad: Puedes cambiar la implementación sin tocar la clase que la consume.

Testabilidad: Puedes pasar mocks o fakes en tests unitarios.

Mantenimiento: Las dependencias están bien definidas y el código es más limpio.

Principios SOLID: Cumples el DIP y ayudas al principio de responsabilidad única (SRP).

🔹 Resumen

Siempre que tengas un servicio que pueda cambiar, evolucionar o probarse de forma aislada, inyecta la interfaz.
Solo inyecta la implementación concreta si es trivial, estable y no se beneficiará de la abstracción.